Kolmogorov complexity.
In algorithmic information theory (a subfield of computer science), the Kolmogorov complexity'" (also known as "'descriptive complexity'", "'Kolmogorov–Chaitin complexity'", "'algorithmic entropy'", or "'program-size complexity'") of an object, such as a piece of text, is a measure of the computational resources needed to specify the object. It is named after Andrey Kolmogorov, who first published on the subject in 1963.
For example, consider the following two strings of length 64, each containing only lowercase letters and digits:
The first string has a short English-language description, namely "ab 32 times", which consists of "'11'" characters. The second one has no obvious simple description (using the same character set) other than writing down the string itself, which has "'64'" characters.
More formally, the complexity of a string is the length of the shortest possible description of the string in some fixed universal description language (the sensitivity of complexity relative to the choice of description language is discussed below). It can be shown that the Kolmogorov complexity of any string cannot be more than a few bytes larger than the length of the string itself. Strings whose Kolmogorov complexity is small relative to the string's size are not considered to be complex.
The notion of the Kolmogorov complexity can be used to state and prove impossibility results akin to Gödel's incompleteness theorem and Turing's halting problem.
Definition.
To define the Kolmogorov complexity, we must first specify a description language for strings. Such a description language can be based on any computer programming language, such as Lisp, Pascal, or Java virtual machine bytecode. If "'P'" is a program which outputs a string "x", then P'" is a description of "x". The length of the description is just the length of P'" as a character string, multiplied by the number of bits in a character (e.g. 7 for ASCII).
We could, alternatively, choose an encoding for Turing machines, where an "encoding" is a function which associates to each Turing Machine M'" a bitstring <"'M'">. If "'M'" is a Turing Machine which, on input "w", outputs string "x", then the concatenated string <M'"> "w" is a description of "x". For theoretical analysis, this approach is more suited for constructing detailed formal proofs and is generally preferred in the research literature. In this article, an informal approach is discussed.
Any string "s" has at least one description, namely the program:
If a description of "s", "d"("s"), is of minimal length (i.e. it uses the fewest characters), it is called a minimal description'" of "s". Thus, the length of "d"("s") (i.e. the number of characters in the description) is the Kolmogorov complexity'" of "s", written "K"("s"). Symbolically,
The length of the shortest description will depend on the choice of description language; but the effect of changing languages is bounded (a result called the "invariance theorem").
Informal treatment.
However, there are some description languages which are optimal, in the following sense: given any description of an object in a description language, I can use that description in my optimal description language with a constant overhead. The constant depends only on the languages involved, not on the description of the object, or the object being described.
Here is an example of an optimal description language. Our descriptions will have two parts:
In more technical terms, the first part of a description is a computer program, with the second part being the input to that computer program which produces the object as output.
The invariance theorem follows: Given any description language [Formula 2], our optimal description language is at least as efficient as [Formula 2], with some constant overhead.
Proof: If we have a description [Formula 4] in [Formula 2], we can convert it into a description in our optimal language by first describing [Formula 2] as a computer program [Formula 7] (part 1), and then using the original description [Formula 4] as input to that program (part 2). The
total length of this new description [Formula 9] is (approximately):
The length of [Formula 7] is a constant that doesn't depend on [Formula 4]. So, there is at most a constant overhead, regardless of the object we're trying to describe. Therefore, it follows that our optimal language is universal up to this additive constant.
A more formal treatment.
Theorem'": If "K"1 and "K"2 are the complexity functions relative to description languages "L"1 and "L"2, then there is a constant "c" – which depends only on the languages "L"1 and "L"2 chosen – such that
Proof'": By symmetry, it suffices to prove that there is some constant "c" such that for all bitstrings "s"
Now, suppose there is a program in the language "L"1 which acts as an interpreter for "L"2:
where "p" is a program in "L"2. The interpreter is characterized by the following property:
Thus, if P'" is a program in "L"2 which is a minimal description of "s", then InterpretLanguage(P'") returns the string "s". The length of this description of "s" is the sum of
This proves the desired upper bound.
History and context.
Algorithmic information theory is the area of computer science that studies Kolmogorov complexity and other complexity measures on strings (or other data structures).
The concept and theory of Kolmogorov Complexity is based on a crucial theorem first discovered by Ray Solomonoff, who published it in 1960, describing it in "A Preliminary Report on a General Theory of Inductive Inference" as part of his invention of algorithmic probability. He gave a more complete description in his 1964 publications, "A Formal Theory of Inductive Inference," Part 1 and Part 2 in "Information and Control".
Andrey Kolmogorov later independently published this theorem in "Problems Inform. Transmission", Gregory Chaitin also presents this theorem in "J. ACM" – Chaitin's paper was submitted October 1966 and revised in December 1968, and cites both Solomonoff's and Kolmogorov's papers.
The theorem says that, among algorithms that decode strings from their descriptions (codes), there exists an optimal one. This algorithm, for all strings, allows codes as short as allowed by any other algorithm up to an additive constant that depends on the algorithms, but not on the strings themselves. Solomonoff used this algorithm, and the code lengths it allows, to define a "universal probability" of a string on which inductive inference of the subsequent digits of the string can be based. Kolmogorov used this theorem to define several functions of strings, including complexity, randomness, and information.
When Kolmogorov became aware of Solomonoff's work, he acknowledged Solomonoff's priority. For several years, Solomonoff's work was better known in the Soviet Union than in the Western World. The general consensus in the scientific community, however, was to associate this type of complexity with Kolmogorov, who was concerned with randomness of a sequence, while Algorithmic Probability became associated with Solomonoff, who focused on prediction using his invention of the universal prior probability distribution.
There are several other variants of Kolmogorov complexity or algorithmic information. The most widely used one is based on self-delimiting programs, and is mainly due to Leonid Levin (1974).
An axiomatic approach to Kolmogorov complexity based on Blum axioms (Blum 1967) was introduced by Mark Burgin in the paper presented for publication by Andrey Kolmogorov (Burgin 1982).
Some consider that naming the concept "Kolmogorov complexity" is an example of the Matthew effect.
Basic results.
In the following discussion, let "K"("s") be the complexity of the string "s".
It is not hard to see that the minimal description of a string cannot be too much larger than the string itself - the program GenerateFixedString above that outputs "s" is a fixed amount larger than "s".
"'Theorem'": There is a constant "c" such that
Incomputability of Kolmogorov complexity.
The first result is that there is no way to compute "K".
"'Theorem'": "K" is not a computable function.
In other words, there is no program which takes a string "s" as input and produces the integer "K"("s") as output. We show this by contradiction by making a program that creates a string that should only be able to be created by a longer program. Suppose there is a program
that takes as input a string "s" and returns "K"("s"). Now, consider the program
for'" i = 1 "'to'" infinity:
"'for each'" string s "'of'" length exactly i
This program calls KolmogorovComplexity as a subroutine. The program tries every string, starting with the shortest, until it finds a string with complexity at least "n" (if there is one), then returns that string (or goes into an infinite loop if there is no such string). Clearly there is always at least one such string for any "n", as otherwise all possible strings (infinitely many) could be generated by the (finitely many) programs with lower complexity, so GenerateComplexString must always return. Therefore, given any positive integer "n", it produces a string with Kolmogorov complexity at least as great as "n". The program itself has a fixed length "U". The input to the program GenerateComplexString is an integer "n". Here, the size of "n" is measured by the number of bits required to represent "n", which is log2("n"). Now, consider the following program:
This program calls GenerateComplexString as a subroutine, and also has a free parameter
"n"0. The program outputs a string "s" whose complexity is at least "n"0. By an auspicious choice of the parameter "n"0, we will arrive at a contradiction. To choose this value, note that "s" is described by the program GenerateParadoxicalString whose length is at most
where "C" is the "overhead" added by the program GenerateParadoxicalString. Since "n" grows faster than log2("n"), there must exist a value "n"0 such that
But this contradicts the definition of "s" as having a complexity at least "n"0. That is, by the definition of "K"("s"), the string "s" returned by GenerateParadoxicalString is only supposed to be able to be generated by a program of length "n"0 or longer, but GenerateParadoxicalString is shorter than "n"0. Thus the program named "KolmogorovComplexity" cannot actually computably find the complexity of arbitrary strings.
This is proof by contradiction, where the contradiction is similar to the Berry paradox: "Let "n" be the smallest positive integer that cannot be defined in fewer than twenty English words". It is also possible to show the non-computability of K by reduction from the non-computability of the halting problem H, since K and H are Turing-equivalent.
In the programming language community there is a corollary known as the full employment theorem, stating that there is no perfect size-optimizing compiler.
Chain rule for Kolmogorov complexity.
The chain rule for Kolmogorov complexity states that
It states that the shortest program that reproduces "X" and "Y" is no more than a logarithmic term larger than a program to reproduce "X" and a program to reproduce "Y" given "X". Using this statement, one can define an analogue of mutual information for Kolmogorov complexity.
Compression.
It is straightforward to compute upper bounds for [Formula 19] – simply compress the string [Formula 20] with some method, implement the corresponding decompressor in the chosen language, concatenate the decompressor to the compressed string, and measure the length of the resulting string.
A string "s" is compressible by a number "c" if it has a description whose length does not exceed [Formula 21]. This is equivalent to saying that [Formula 22]. Otherwise, "s" is incompressible by "c". A string incompressible by 1 is said to be simply "incompressible" – by the pigeonhole principle, which applies because every compressed string maps to only one uncompressed string, incompressible strings must exist, since there are [Formula 23] bit strings of length "n", but only [Formula 24] shorter strings, that is, strings of length less than "n", (i.e. with length 0,1...,"n − 1).
For the same reason, most strings are complex in the sense that they cannot be significantly compressed – [Formula 19] is not much smaller than [Formula 26], the length of "s" in bits. To make this precise, fix a value of "n". There are [Formula 23] bitstrings of length "n". The uniform probability distribution on the space of these bitstrings assigns exactly equal weight [Formula 28] to each string of length "n".
"'Theorem'": With the uniform probability distribution on the space of bitstrings of length "n", the probability that a string is incompressible by "c" is at least [Formula 29].
To prove the theorem, note that the number of descriptions of length not exceeding [Formula 30] is given by the geometric series:
bitstrings of length "n" that are incompressible by "c". To determine the probability, divide by [Formula 23].
Chaitin's incompleteness theorem.
We know that, in the set of all possible strings, most strings are complex in the sense that they cannot be described in any significantly "compressed" way. However, it turns out that the fact that a specific string is complex cannot be formally proven, if the complexity of the string is above a certain threshold. The precise formalization is as follows. First, fix a particular axiomatic system S'" for the natural numbers. The axiomatic system has to be powerful enough so that, to certain assertions "'A'" about complexity of strings, one can associate a formula "'F'"A in "'S'". This association must have the following property:
if "'F'"A is provable from the axioms of "'S'", then the corresponding assertion "'A'" must be true. This "formalization" can be achieved, either by an artificial encoding such as a Gödel numbering, or by a formalization which more clearly respects the intended interpretation of "'S'".
"'Theorem'": There exists a constant "L" (which only depends on the particular axiomatic system and the choice of description language) such that there does not exist a string "s" for which the statement
Note that, by the abundance of nearly incompressible strings, the vast majority of those statements must be true.
The proof of this result is modeled on a self-referential construction used in Berry's paradox. The proof is by contradiction. If the theorem were false, then
We can find an effective enumeration of all the formal proofs in "'S'" by some procedure
which takes as input "n" and outputs some proof. This function enumerates all proofs. Some of these are proofs for formulas we do not care about here, since every possible proof in the language of S'" is produced for some "n". Some of these are complexity formulas of the form "K"("s") ≥ "n" where "s" and "n" are constants in the language of S'". There is a program
which determines whether the "n"th proof actually proves a complexity formula "K"("s") ≥ "L". The strings "s", and the integer "L" in turn, are computable by programs:
for'" i = 1 to infinity:
"'if'" NthProofProvesComplexityFormula(i) "'and'" ComplexityLowerBoundNthProof(i) ≥ "n"
Given an "n", this program tries every proof until it finds a string and a proof in the formal system S'" of the formula "K"("s") ≥ "L" for some "L" ≥ "n". The program terminates by our Assumption (X). Now, this program has a length "U". There is an integer "n"0 such that "U" + log2("n"0) + "C" < "n"0, where "C" is the overhead cost of
(note that "n"0 is hard-coded into the above function, and the summand log2("n"0) already allows for its encoding). The program GenerateProvablyParadoxicalString outputs a string "s" for which there exists an "L" such that "K"("s") ≥ "L" can be formally proved in S'" with "L" ≥ "n"0. In particular, "K"("s") ≥ "n"0 is true. However, "s" is also described by a program of length "U" + log2("n"0) + "C", so its complexity is less than "n"0. This contradiction proves Assumption (X) cannot hold.
Similar ideas are used to prove the properties of Chaitin's constant.
Minimum message length.
The minimum message length principle of statistical and inductive inference and machine learning was developed by C.S. Wallace and D.M. Boulton in 1968. MML is Bayesian (i.e. it incorporates prior beliefs) and information-theoretic. It has the desirable properties of statistical invariance (i.e. the inference transforms with a re-parametrisation, such as from polar coordinates to Cartesian coordinates), statistical consistency (i.e. even for very hard problems, MML will converge to any underlying model) and efficiency (i.e. the MML model will converge to any true underlying model about as quickly as is possible). C.S. Wallace and D.L. Dowe (1999) showed a formal connection between MML and algorithmic information theory (or Kolmogorov complexity).
Kolmogorov randomness.
"Kolmogorov randomness" – also called "algorithmic randomness" – defines a string (usually of bits) as being random if and only if it is shorter than any computer program that can produce that string. To make this precise, a universal computer (or universal Turing machine) must be specified, so that "program" means a program for this universal machine. A random string in this sense is "incompressible" in that it is impossible to "compress" the string into a program whose length is shorter than the length of the string itself. A counting argument is used to show that, for any universal computer, there is at least one algorithmically random string of each length. Whether any particular string is random, however, depends on the specific universal computer that is chosen.
This definition can be extended to define a notion of randomness for "infinite" sequences from a finite alphabet. These algorithmically random sequences can be defined in three equivalent ways. One way uses an effective analogue of measure theory; another uses effective martingales. The third way defines an infinite sequence to be random if the prefix-free Kolmogorov complexity of its initial segments grows quickly enough - there must be a constant "c" such that the complexity of an initial segment of length "n" is always at least "n"−"c". This definition, unlike the definition of randomness for a finite string, is not affected by which universal machine is used to define prefix-free Kolmogorov complexity.
Relation to entropy.
For dynamical systems, entropy rate and algorithmic complexity of the trajectories are related by a theorem of Brudno, that the equality K(x;T) = h(T) holds for almost all x.
It can be shown that for the output of Markov information sources, Kolmogorov complexity is related to the entropy of the information source. More precisely, the Kolmogorov complexity of the output of a Markov information source, normalized by the length of the output, converges almost surely (as the length of the output goes to infinity) to the entropy of the source.
